package rs.ac.bg.etf.pp1;

import java_cup.runtime.*;
import org.apache.log4j.*;
import rs.ac.bg.etf.pp1.ast.*;


parser code {:
	
	boolean errorDetected = false;
	
	Logger log = Logger.getLogger(getClass());
   
   
    // slede redefinisani metodi za prijavu gresaka radi izmene teksta poruke
     
    public void report_fatal_error(String message, Object info) throws java.lang.Exception {
      done_parsing();
      report_error(message, info);
    }
  
    public void syntax_error(Symbol cur_token) {
        report_error("\nSintaksna greska", cur_token);
    }
  
    public void unrecovered_syntax_error(Symbol cur_token) throws java.lang.Exception {
        report_fatal_error("Fatalna greska, parsiranje se ne moze nastaviti", cur_token);
    }

    public void report_error(String message, Object info) {
    	errorDetected = true;
    	StringBuilder msg = new StringBuilder(message); 
    	if (info instanceof Symbol)
            msg.append (" na liniji ").append(((Symbol)info).left);
        log.error(msg.toString());
    }
    
    public void report_info(String message, Object info) {
    	StringBuilder msg = new StringBuilder(message); 
    	if (info instanceof Symbol)
            msg.append (" na liniji ").append(((Symbol)info).left);
        log.info(msg.toString());
    }
    
:}

scan with {:
	Symbol s = this.getScanner().next_token();
	if (s != null && s.value != null) 
		log.info(s.toString() + " " + s.value.toString());
	return s;
:}

terminal PROG, LBRACE, RBRACE, CONST, COMMA, ASSIGN, SEMI, LBRACKET, RBRACKET;
terminal CLASS, EXTENDS, LPAREN, RPAREN, VOID, EQ, NEQ, GT, GTE, LT, LTE;
terminal PLUS, MINUS, MUL, MOD, DIV, IF, ELSE, BREAK, CONTINUE, RETURN, READ, PRINT;
terminal DOT, FOREACH, OR, AND, NEW;
terminal String IDENT, CHAR, BOOL;
terminal Integer NUM;

nonterminal Program, DeclarationList, MethodDeclarationList, Declaration, ConstDecl;
nonterminal VarDecl, ClassDecl, Type, Constant, MultipleConstDecl, SingleVarDecl;
nonterminal MultipleVarDecl, VarDeclList, ConstructorDeclList, ConstructorDecl;
nonterminal MethodDeclList, MethodDecl, ClassDeclName, StatementList, Statement;
nonterminal FormPars, MethodDeclReturn, Label, Assignop, Relop, Addop, Mulop;
nonterminal DesignatorStatement, Expr, Designator, PrintArgs, ActPars, DesignatorList;
nonterminal Condition, CondTerm, CondFact, DesignatorIdentExprList;

Program ::= (Program) PROG IDENT DeclarationList LBRACE MethodDeclarationList RBRACE;

DeclarationList ::= (DeclarationList) DeclarationList Declaration
					|
					(NoDeclaration) /* epsilon */
					;
					
Declaration ::= (ConstDeclaration) ConstDecl
				|
				(VarDeclaration) VarDecl
				|
				(ClassDeclaration) ClassDecl
				;
				
ConstDecl ::= 	(SingleConstDecl) CONST Type IDENT ASSIGN Constant SEMI
				|
				(MultipleConstDecl) CONST Type IDENT ASSIGN Constant MultipleConstDecl SEMI
				;
				
MultipleConstDecl ::= 	(LastMultipleConstDecl) COMMA IDENT ASSIGN Constant
						|
						(MultipleConstDeclList) COMMA IDENT ASSIGN Constant MultipleConstDecl
						;

Constant ::= 	(NumConst) NUM
				|
				(CharConst) CHAR
				|
				(BoolConst) BOOL
				;

VarDecl ::= 	(VarDecl) SingleVarDecl SEMI
				|
				(MultipleVarDecl) SingleVarDecl MultipleVarDecl SEMI
				;
				
SingleVarDecl ::= 	(SingleVarDecl) Type IDENT
					|
					(SingleVarArrayDecl) Type IDENT LBRACKET RBRACKET
					;

MultipleVarDecl ::= (LastMultipleVarDecl) COMMA SingleVarDecl
					|
					(MultipleVarDeclList) COMMA SingleVarDecl MultipleVarDecl

ClassDeclName ::= 	(ClassDeclNameExtend) CLASS IDENT EXTENDS Type
					|
					(ClassDeclName) CLASS IDENT
					;
					
VarDeclList ::= (VarDeclList) VarDeclList VarDecl
				|
				(EmptyVarDeclList) /* epsilon */
				;
					
ClassDecl ::= 	(ClassDecl) ClassDeclName LBRACE VarDeclList RBRACE
				|
				(ClassDeclMethods) ClassDeclName LBRACE VarDeclList LBRACE ConstructorDeclList MethodDeclList RBRACE RBRACE
				;

ConstructorDeclList ::= (ConstructorDeclList) ConstructorDeclList ConstructorDecl
						|
						(EmptyConstructorDeclList) /* epsilon */
						;

MethodDeclList ::= 	(MethodDeclList) MethodDeclList MethodDecl
					|
					(EmptyMethodDeclList) /* epsilon */
					;

ConstructorDecl ::= (ConstructorDecl) IDENT LPAREN RPAREN VarDeclList LBRACE StatementList RBRACE
					|
					(ConstructorDeclFormParams) IDENT LPAREN FormPars RPAREN VarDeclList LBRACE StatementList RBRACE
					;

StatementList ::= 	(StatementList) StatementList Statement
					|
					(EmptyStatementList) /* epsilon */
					;

MethodDeclReturn ::= 	(MethodDeclReturnVoid) VOID
						|
						(MethodDeclReturn) Type
						;

MethodDecl ::= 	(MethodDecl) MethodDeclReturn IDENT LPAREN FormPars RPAREN VarDeclList LBRACE StatementList RBRACE
				|
				(MethodDeclFormPars) MethodDeclReturn IDENT LPAREN RPAREN VarDeclList LBRACE StatementList RBRACE
				;

FormPars ::= 	(FormPar) SingleVarDecl
				|
				(FormPars) SingleVarDecl COMMA FormPars
				;
				
Type ::= (Type) IDENT;

Statement ::= 	(DesignatorStmt) DesignatorStatement SEMI
				|
				(IfElseStmt) IF LPAREN Condition RPAREN Statement ELSE Statement
				|
				(IfStmt) IF LPAREN Condition RPAREN Statement
				|
				(BreakStmt) BREAK SEMI
				|
				(ContinueStmt) CONTINUE SEMI
				|
				(ReturnEmptyStmt) RETURN SEMI
				|
				(ReturnStmt) RETURN Expr SEMI
				|
				(ReadStmt) READ LPAREN Designator RPAREN SEMI
				|
				(PrintStmt) PRINT LPAREN Expr PrintArgs RPAREN SEMI
				|
				(ForeachStmt) Designator DOT FOREACH LPAREN IDENT ARROW Statement RPAREN SEMI
				|
				(BlockStmt) LBRACE StatementList RBRACE
				;

PrintArgs ::= 	(PrintArgs) COMMA NUM PrintArgs
				|
				(PrintArgsEmpty) /* epsilon */
				;
				
DesignatorStatement ::= (DesignatorAssignStmt) Designator Assignop Expr
						|
						(DesignatorActParsStmt) Designator LPAREN ActPars RPAREN
						|
						(DesignatorEmptyActParsStmt) Designator LPAREN RPAREN
						|
						(DesignatorIncStmt) Designator PLUS PLUS
						|
						(DesignatorDecStmt) Designator MINUS MINUS
						|
						(DesignatorEmptyAssignStmt) LBRACKET RBRACKET ASSIGN Designator
						|
						(DesignatorAssignStmt) LBRACKET Designator DesignatorList RBRACKET ASSIGN Designator
						;

DesignatorList ::= 	(DesignatorList) DesignatorList COMMA Designator
					|
					(EmptyDesignatorList) /* epsilon */
					;
					
ActPars ::= (ActPar) Expr
			|
			(ActPars) Expr COMMA ActPars
			;
			
Condition ::= 	(SingleCondition) CondTerm
				|
				(MultipleConditions) CondTerm OR Condition
				;
				
CondTerm ::= 	(SingleCondTerm) CondFact
				|
				(MultipleCondTerm) CondFact AND CondTerm
				;
				
CondFact ::= 	(SingleExpr) Expr
				|
				(MultipleExpr) Expr Relop Expr
				;
				
Expr ::=	(PosExpr) Term AddopTermList
			|
			(NegExpr) MINUS Term AddopTermList
			;
			
AddopTermList ::= 	(AddopTermList) Addop Term AddopTermList
					|
					(EmptyAddopTermList) /* epsilon */
					;
					
Term ::=	(SingleFactor) Factor
			|
			(MultipleFactors) Term Mulop Factor
			;
			
Factor ::= 	(FactorDesignatorEmpty) Designator
			|
			(FactorDesignatorActPars) Designator LPAREN ActPars RPAREN
			|
			(FactorNum) NUM
			|
			(FactorChar) CHAR
			|
			(FactorBool) BOOL
			|
			(FactorNewExpr) NEW Type LBRACKET Expr RBRACKET
			|
			(FactorNewActPars) NEW Type LPAREN ActPars RPAREN
			|
			(FactorNewActParsEmpty) NEW Type LPAREN RPAREN
			|
			(FactorExpr) LPAREN Expr RPAREN
			;
			

Designator ::= 	(DesignatorIdent) IDENT DesignatorIdentExprList;

DesignatorIdentExprList ::= (DesignatorDotIdent) DesignatorIdentExprList DOT IDENT
							|
							(DesignatorExpr) DesignatorIdentExprList LBRACKET Expr RBRACKET
							|
							(DesignatorIdentExprListEmpty) /* epsilon */
							;

Label ::= (Label) IDENT;

Assignop ::= (Assignop) ASSIGN;

Relop ::= 	(Equals) EQ
			|
			(NotEquals) NEQ
			|
			(Greater) GT
			|
			(GreaterEquals) GTE
			|
			(Lesser) LT
			|
			(LesserEquals) LTE
			;

Addop ::= 	(Plus) PLUS
			|
			(Minus) MINUS
			;
			
Mulop ::=	(Mul) MUL
			|
			(Div) DIV
			|
			(Mod) MOD
			;
